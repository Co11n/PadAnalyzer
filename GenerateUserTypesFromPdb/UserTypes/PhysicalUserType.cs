using Dia2Lib;
using System.Collections.Generic;

namespace GenerateUserTypesFromPdb.UserTypes
{
    class PhysicalUserType : UserType
    {
        private const string ClassCodeType = "ClassCodeType";

        public PhysicalUserType(Symbol symbol, XmlType xmlType, string nameSpace)
            : base(symbol, xmlType, nameSpace)
        {
        }

        protected override IEnumerable<UserTypeField> GetAutoGeneratedFields(bool hasNonStatic, bool useThisClass)
        {
            if (hasNonStatic && useThisClass)
            {
                // TODO: Remove this in the future
                yield return new UserTypeField
                {
                    ConstructorText = string.Format("variable.GetBaseClass(baseClassString)"),
                    FieldName = "thisClass",
                    FieldType = "Variable",
                    FieldTypeInfoComment = null,
                    PropertyName = null,
                    Static = false,
                    UseUserMember = true,
                    CacheResult = true,
                };
            }

            yield return new UserTypeField
            {
                Access = "public",
                ConstructorText = string.Format("CodeType.Create(\"{0}!{1}\")", Symbol.Module.Name, TypeName),
                FieldName = ClassCodeType,
                FieldType = "CodeType",
                FieldTypeInfoComment = null,
                PropertyName = null,
                Static = true,
                UseUserMember = false,
                CacheResult = true,
            };

            yield return new UserTypeField
            {
                ConstructorText = string.Format("GetBaseClassString(typeof({0}))", FullClassName),
                FieldName = "baseClassString",
                FieldType = "string",
                FieldTypeInfoComment = null,
                PropertyName = null,
                Static = true,
                UseUserMember = false,
                CacheResult = true,
            };

            yield return new UserTypeFunction
            {
                FieldName = "PartialInitialize",
                FieldType = "partial void",
                CacheResult = true,
            };
        }

        protected override IEnumerable<UserTypeConstructor> GenerateConstructors()
        {
            yield return new UserTypeConstructor()
            {
                ContainsFieldDefinitions = true,
                Static = true,
            };

            yield return new UserTypeConstructor()
            {
                Arguments = "Variable variable",
                BaseClassInitialization = string.Format("this(variable.GetBaseClass(baseClassString), Debugger.ReadMemory(variable.GetCodeType().Module.Process, variable.GetBaseClass(baseClassString).GetPointerAddress(), {0}), 0, variable.GetBaseClass(baseClassString).GetPointerAddress())", Symbol.Size),
                ContainsFieldDefinitions = false,
                Static = false,
            };

            yield return new UserTypeConstructor()
            {
                Arguments = "Variable variable, CsScriptManaged.Utility.MemoryBuffer buffer, int offset, ulong bufferAddress",
                BaseClassInitialization = "base(variable, buffer, offset, bufferAddress)",
                ContainsFieldDefinitions = true,
                Static = false,
            };
        }

        protected override UserTypeField ExtractField(SymbolField field, UserTypeTree fieldType, UserTypeFactory factory, string simpleFieldValue, string gettingField, bool isStatic, UserTypeGenerationFlags options, bool extractingBaseClass)
        {
            if (!isStatic)
            {
                bool lazyCacheUserTypeFields = options.HasFlag(UserTypeGenerationFlags.LazyCacheUserTypeFields);
                bool cacheUserTypeFields = options.HasFlag(UserTypeGenerationFlags.CacheUserTypeFields);
                bool cacheStaticUserTypeFields = options.HasFlag(UserTypeGenerationFlags.CacheStaticUserTypeFields);
                string constructorText = "";
                string fieldName = field.Name;
                string fieldTypeString = fieldType.GetUserTypeString();
                UserTypeTreeBaseType baseType = fieldType as UserTypeTreeBaseType;
                UserTypeTreeCodeArray codeArrayType = fieldType as UserTypeTreeCodeArray;
                UserTypeTreeUserType userType = fieldType as UserTypeTreeUserType;
                UserTypeTreeTransformation transformationType = fieldType as UserTypeTreeTransformation;
                bool isEmbedded = field.Type.Tag != SymTagEnum.SymTagPointerType;

                if (baseType != null)
                {
                    if (baseType.BaseType == "string")
                    {
                        int charSize = field.Type.ElementType.Size;

                        constructorText = string.Format("ReadString(GetCodeType().Module.Process, ReadPointer(memoryBuffer, memoryBufferOffset + {0}, {1}), {2})", field.Offset, field.Type.Size, charSize);
                    }
                    else if (baseType.BaseType != "NakedPointer")
                    {
                        if (field.LocationType == LocationType.BitField)
                            constructorText = string.Format("Read{0}(memoryBuffer, memoryBufferOffset + {1}, {2}, {3})", baseType.GetUserTypeString().UppercaseFirst(), field.Offset, field.Size, field.BitPosition);
                        else
                            constructorText = string.Format("Read{0}(memoryBuffer, memoryBufferOffset + {1})", baseType.GetUserTypeString().UppercaseFirst(), field.Offset);
                    }
                }
                else if (codeArrayType != null)
                {
                    if (codeArrayType.InnerType is UserTypeTreeBaseType)
                    {
                        baseType = (UserTypeTreeBaseType)codeArrayType.InnerType;
                        if (baseType != null && baseType.BaseType != "string" && baseType.BaseType != "NakedPointer")
                        {
                            int arraySize = field.Type.Size;
                            int elementSize = field.Type.ElementType.Size;

                            if (baseType.BaseType == "char")
                                constructorText = string.Format("Read{0}Array(memoryBuffer, memoryBufferOffset + {1}, {2}, {3})", baseType.GetUserTypeString().UppercaseFirst(), field.Offset, arraySize / elementSize, elementSize);
                            else
                                constructorText = string.Format("Read{0}Array(memoryBuffer, memoryBufferOffset + {1}, {2})", baseType.GetUserTypeString().UppercaseFirst(), field.Offset, arraySize / elementSize);
                            fieldTypeString = baseType.GetUserTypeString() + "[]";
                        }
                    }
                }
                else if (userType != null)
                {
                    if (!(userType.UserType is EnumUserType) && !extractingBaseClass)
                    {
                        string thisClassCodeType = ClassCodeType;

                        if (!isEmbedded)
                        {
                            string fieldAddress = string.Format("ReadPointer(memoryBuffer, memoryBufferOffset + {0}, {1})", field.Offset, field.Type.Size);

                            constructorText = string.Format("ReadPointer<{0}>({4}, \"{1}\", memoryBuffer, memoryBufferOffset + {2}, {3})", fieldTypeString, fieldName, field.Offset, field.Type.Size, ClassCodeType);
                        }
                        else
                        {
                            string fieldAddress = string.Format("memoryBufferAddress + (ulong)(memoryBufferOffset + {0})", field.Offset);
                            string fieldVariable = string.Format("Variable.CreateNoCast({0}.GetClassFieldType(\"{1}\"), {2}, \"{1}\")", thisClassCodeType, fieldName, fieldAddress);

                            constructorText = string.Format("new {0}({1}, memoryBuffer, memoryBufferOffset + {2}, memoryBufferAddress)", fieldTypeString, fieldVariable, field.Offset);
                        }
                    }
                }
                else if (transformationType != null)
                {
                    if (!isEmbedded)
                    {
                        string thisClassCodeType = ClassCodeType;
                        string fieldAddress = string.Format("memoryBufferAddress + (ulong)(memoryBufferOffset + {0})", field.Offset);
                        string fieldVariable = string.Format("Variable.CreateNoCast({0}.GetClassFieldType(\"{1}\"), {2}, \"{1}\")", thisClassCodeType, fieldName, fieldAddress);

                        if (transformationType.Transformation.Transformation.HasPhysicalConstructor)
                        {
                            fieldVariable = string.Format("{0}, memoryBuffer, memoryBufferOffset + {1}, memoryBufferAddress", fieldVariable, field.Offset);
                        }

                        simpleFieldValue = fieldVariable;
                        constructorText = string.Format("new {0}({1})", fieldTypeString, fieldVariable);
                    }
                }

                if (!string.IsNullOrEmpty(constructorText))
                    return new UserTypeField()
                    {
                        ConstructorText = constructorText,
                        FieldName = "_" + fieldName,
                        FieldType = fieldTypeString,
                        FieldTypeInfoComment = string.Format("// {0} {1};", field.Type.Name, fieldName),
                        PropertyName = UserTypeField.GetPropertyName(fieldName, Symbol.Name),
                        Static = isStatic,
                        UseUserMember = lazyCacheUserTypeFields,
                        CacheResult = cacheUserTypeFields || (isStatic && cacheStaticUserTypeFields),
                        SimpleFieldValue = simpleFieldValue,
                    };
            }

            return base.ExtractField(field, fieldType, factory, simpleFieldValue, gettingField, isStatic, options, extractingBaseClass);
        }
    }
}
