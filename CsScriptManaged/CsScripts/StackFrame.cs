using CsScriptManaged;
using System;
using System.Collections.Generic;
using System.Linq;
using DbgEngManaged;
using System.Text;
using System.Runtime.InteropServices;

namespace CsScripts
{
    public class StackFrame
    {
        /// <summary>
        /// The frame
        /// </summary>
        private _DEBUG_STACK_FRAME frame;

        private string sourceFileName;
        private uint sourceFileLine;

        /// <summary>
        /// Initializes a new instance of the <see cref="StackFrame"/> class.
        /// </summary>
        /// <param name="stackTrace">The stack trace.</param>
        /// <param name="frame">The frame.</param>
        internal StackFrame(StackTrace stackTrace, _DEBUG_STACK_FRAME frame)
        {
            StackTrace = stackTrace;
            this.frame = frame;
        }

        /// <summary>
        /// Gets the owning stack trace.
        /// </summary>
        public StackTrace StackTrace { get; internal set; }

        /// <summary>
        /// Gets the owning thread.
        /// </summary>
        public Thread Thread
        {
            get
            {
                return StackTrace.Thread;
            }
        }

        /// <summary>
        /// Gets a value indicating whether this <see cref="StackFrame"/> is virtual.
        /// </summary>
        /// <value>
        ///   <c>true</c> if this stack frame was generated by the debugger by unwinding; otherwise, <c>false</c> if it
        ///   was formed from a thread's current context. Typically, this is <c>true</c> for the frame at the top of the
        ///   stack, where InstructionOffset is the current instruction pointer.
        /// </value>
        public bool Virtual
        {
            get
            {
                return frame.Virtual != 0;
            }
        }

        /// <summary>
        /// Gets the index of the frame. This index counts the number of frames from the top of the call stack.
        /// The frame at the top of the stack, representing the current call, has index zero..
        /// </summary>
        public uint FrameNumber
        {
            get
            {
                return frame.FrameNumber;
            }
        }

        /// <summary>
        /// Gets the location in the process's virtual address space of the stack frame, if known.
        /// Some processor architectures do not have a frame or have more than one. In these cases,
        /// the engine chooses a value most representative for the given level of the stack.
        /// </summary>
        public ulong FrameOffset
        {
            get
            {
                return frame.FrameOffset;
            }
        }

        /// <summary>
        /// Gets the location in the process's virtual address space of the related instruction for the stack frame.
        /// This is typically the return address for the next stack frame, or the current instruction pointer if the
        /// frame is at the top of the stack. 
        /// </summary>
        public ulong InstructionOffset
        {
            get
            {
                return frame.InstructionOffset;
            }
        }

        /// <summary>
        /// Gets the location in the process's virtual address space of the return address for the stack frame.
        /// This is typically the related instruction for the previous stack frame.
        /// </summary>
        public ulong ReturnOffset
        {
            get
            {
                return frame.ReturnOffset;
            }
        }

        /// <summary>
        /// Gets the location in the process's virtual address space of the processor stack.
        /// </summary>
        public ulong StackOffset
        {
            get
            {
                return frame.StackOffset;
            }
        }

        private void ReadSourceFileName()
        {
            try
            {
                uint fileNameLength;
                ulong displacement;
                StringBuilder sb = new StringBuilder(Constants.MaxFileName);

                Context.Symbols.GetLineByOffset(InstructionOffset, out sourceFileLine, sb, (uint)sb.Capacity, out fileNameLength, out displacement);
                sourceFileName = sb.ToString();
            }
            catch (Exception ex)
            {
                throw new AggregateException("Couldn't read source file name. Check if symbols are present.", ex);
            }
        }

        public string SourceFileName
        {
            get
            {
                if (string.IsNullOrEmpty(sourceFileName))
                {
                    ReadSourceFileName();
                }

                return sourceFileName;
            }
        }

        public uint SourceFileLine
        {
            get
            {
                if (string.IsNullOrEmpty(sourceFileName))
                {
                    ReadSourceFileName();
                }

                return sourceFileLine;
            }
        }

        public string FunctionName
        {
            get
            {
                try
                {
                    uint functionNameSize;
                    ulong displacement;
                    StringBuilder sb = new StringBuilder(Constants.MaxSymbolName);

                    Context.Symbols.GetNameByOffset(InstructionOffset, sb, (uint)sb.Capacity, out functionNameSize, out displacement);
                    return sb.ToString();
                }
                catch (Exception ex)
                {
                    throw new AggregateException("Couldn't read source file name. Check if symbols are present.", ex);
                }
            }
        }

        public Variable[] Locals
        {
            get
            {
                return GetVariables(DebugScopeGroup.Locals);
            }
        }

        public Variable[] Arguments
        {
            get
            {
                return GetVariables(DebugScopeGroup.Arguments);
            }
        }

        private Variable[] GetVariables(DebugScopeGroup scopeGroup)
        {
            using (StackFrameSwitcher switcher = new StackFrameSwitcher(this))
            {
                IDebugSymbolGroup2 symbolGroup;
                Context.Symbols.GetScopeSymbolGroup2((uint)scopeGroup, null, out symbolGroup);
                uint localsCount = symbolGroup.GetNumberSymbols();
                Variable[] variables = new Variable[localsCount];
                for (uint i = 0; i < localsCount; i++)
                {
                    StringBuilder name = new StringBuilder(Constants.MaxSymbolName);
                    uint nameSize;

                    symbolGroup.GetSymbolName(i, name, (uint)name.Capacity, out nameSize);
                    var entry = symbolGroup.GetSymbolEntryInformation(i);

                    variables[i] = new Variable(name.ToString(), entry);
                }

                return variables;
            }
        }
    }
}
