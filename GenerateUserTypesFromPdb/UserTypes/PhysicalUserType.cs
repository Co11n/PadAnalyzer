using Dia2Lib;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace GenerateUserTypesFromPdb.UserTypes
{
    class PhysicalUserType : UserType
    {
        public PhysicalUserType(IDiaSymbol symbol, XmlType xmlType, string moduleName)
            : base(symbol, xmlType, moduleName)
        {
            if (symbol.name.Contains("UniquePartitionsIterator"))
            {

            }
        }

        protected override IEnumerable<UserTypeField> GetAutoGeneratedFields(bool hasNonStatic, bool useThisClass)
        {
            if (hasNonStatic && useThisClass)
            {
                // TODO: Remove this in the future
                yield return new UserTypeField
                {
                    ConstructorText = string.Format("variable.GetBaseClass(baseClassString)"),
                    FieldName = "thisClass",
                    FieldType = "Variable",
                    FieldTypeInfoComment = null,
                    PropertyName = null,
                    Static = false,
                    UseUserMember = true,
                    CacheResult = true,
                };
            }

            yield return new UserTypeField
            {
                ConstructorText = string.Format("GetBaseClassString(typeof({0}))", FullClassName),
                FieldName = "baseClassString",
                FieldType = "string",
                FieldTypeInfoComment = null,
                PropertyName = null,
                Static = true,
                UseUserMember = false,
                CacheResult = true,
            };
        }

        protected override IEnumerable<UserTypeConstructor> GenerateConstructors()
        {
            yield return new UserTypeConstructor()
            {
                ContainsFieldDefinitions = true,
                Static = true,
            };

            yield return new UserTypeConstructor()
            {
                Arguments = "Variable variable",
                BaseClassInitialization = string.Format("this(variable.GetBaseClass(baseClassString), Debugger.ReadMemory(variable.GetCodeType().Module.Process, variable.GetBaseClass(baseClassString).GetPointerAddress(), {0}), 0, variable.GetBaseClass(baseClassString).GetPointerAddress())", Symbol.length),
                ContainsFieldDefinitions = false,
                Static = false,
            };

            yield return new UserTypeConstructor()
            {
                Arguments = "Variable variable, byte[] buffer, int offset, ulong bufferAddress",
                BaseClassInitialization = "base(variable, buffer, offset, bufferAddress)",
                ContainsFieldDefinitions = true,
                Static = false,
            };
        }

        protected override UserTypeField ExtractField(IDiaSymbol field, UserTypeTree fieldType, UserTypeFactory factory, string simpleFieldValue, string gettingField, bool isStatic, UserTypeGenerationFlags options, bool extractingBaseClass)
        {
            if (!isStatic)
            {
                bool lazyCacheUserTypeFields = options.HasFlag(UserTypeGenerationFlags.LazyCacheUserTypeFields);
                bool cacheUserTypeFields = options.HasFlag(UserTypeGenerationFlags.CacheUserTypeFields);
                bool cacheStaticUserTypeFields = options.HasFlag(UserTypeGenerationFlags.CacheStaticUserTypeFields);
                string constructorText = "";
                string fieldName = field.name;
                string fieldTypeString = fieldType.GetUserTypeString();
                UserTypeTreeBaseType baseType = fieldType as UserTypeTreeBaseType;
                UserTypeTreeCodeArray codeArrayType = fieldType as UserTypeTreeCodeArray;
                UserTypeTreeUserType userType = fieldType as UserTypeTreeUserType;
                UserTypeTreeTransformation transformationType = fieldType as UserTypeTreeTransformation;
                bool isEmbedded = (SymTagEnum)field.type.symTag != SymTagEnum.SymTagPointerType;

                if (baseType != null)
                {
                    if (baseType.BaseType == "string")
                    {
                        ulong charSize = field.type.type.length;

                        constructorText = string.Format("ReadString(GetCodeType().Module.Process, ReadPointer(memoryBuffer, memoryBufferOffset + {0}, {1}), {2})", field.offset, field.type.length, charSize);
                    }
                    else if (baseType.BaseType != "NakedPointer")
                    {
                        if ((LocationType)field.locationType == LocationType.BitField)
                        {
                            ulong bits = field.length;
                            ulong bitsOffset = field.bitPosition;

                            constructorText = string.Format("Read{0}(memoryBuffer, memoryBufferOffset + {1}, {2}, {3})", baseType.GetUserTypeString().UppercaseFirst(), field.offset, field.length, field.bitPosition);
                        }
                        else
                            constructorText = string.Format("Read{0}(memoryBuffer, memoryBufferOffset + {1})", baseType.GetUserTypeString().UppercaseFirst(), field.offset);
                    }
                }
                else if (codeArrayType != null)
                {
                    if (codeArrayType.InnerType is UserTypeTreeBaseType)
                    {
                        baseType = (UserTypeTreeBaseType)codeArrayType.InnerType;
                        if (baseType != null && baseType.BaseType != "string" && baseType.BaseType != "NakedPointer")
                        {
                            ulong arraySize = field.type.length;
                            ulong elementSize = field.type.type.length;

                            if (baseType.BaseType == "char")
                                constructorText = string.Format("Read{0}Array(memoryBuffer, memoryBufferOffset + {1}, {2}, {3})", baseType.GetUserTypeString().UppercaseFirst(), field.offset, arraySize / elementSize, elementSize);
                            else
                                constructorText = string.Format("Read{0}Array(memoryBuffer, memoryBufferOffset + {1}, {2})", baseType.GetUserTypeString().UppercaseFirst(), field.offset, arraySize / elementSize);
                            fieldTypeString = baseType.GetUserTypeString() + "[]";
                        }
                    }
                }
                else if (userType != null)
                {
                    if (!(userType.UserType is EnumUserType) && !(userType.UserType is TemplateUserType) && !extractingBaseClass)
                    {
                        string thisClassCodeType = "thisClass.Value.GetCodeType()";

                        if (!isEmbedded)
                        {
                            string fieldAddress = string.Format("ReadPointer(memoryBuffer, memoryBufferOffset + {0}, {1})", field.offset, field.type.length);
                            string fieldVariable = string.Format("Variable.CreatePointer({0}.GetClassFieldType(\"{1}\"), {2}, \"{1}\")", thisClassCodeType, fieldName, fieldAddress);

                            constructorText = string.Format("ReadPointer<{0}>(thisClass, \"{1}\", memoryBuffer, memoryBufferOffset + {2}, {3})", fieldTypeString, fieldName, field.offset, field.type.length);
                        }
                        else
                        {
                            string fieldAddress = string.Format("memoryBufferAddress + (ulong)(memoryBufferOffset + {0})", field.offset);
                            string fieldVariable = string.Format("Variable.Create({0}.GetClassFieldType(\"{1}\"), {2}, \"{1}\")", thisClassCodeType, fieldName, fieldAddress);

                            constructorText = string.Format("new {0}({1}, memoryBuffer, memoryBufferOffset + {2}, memoryBufferAddress)", fieldTypeString, fieldVariable, field.offset);
                        }
                    }
                }
                else if (transformationType != null)
                {
                    if (!isEmbedded)
                    {
                        string thisClassCodeType = "thisClass.Value.GetCodeType()";
                        string fieldAddress = string.Format("memoryBufferAddress + (ulong)(memoryBufferOffset + {0})", field.offset);
                        string fieldVariable = string.Format("Variable.Create({0}.GetClassFieldType(\"{1}\"), {2}, \"{1}\")", thisClassCodeType, fieldName, fieldAddress);

                        if (transformationType.Transformation.Transformation.HasPhysicalConstructor)
                        {
                            fieldVariable = string.Format("{0}, memoryBuffer, memoryBufferOffset + {1}, memoryBufferAddress", fieldVariable, field.offset);
                        }

                        simpleFieldValue = fieldVariable;
                        constructorText = string.Format("new {0}({1})", fieldTypeString, fieldVariable);
                    }
                }

                if (!string.IsNullOrEmpty(constructorText))
                    return new UserTypeField()
                    {
                        ConstructorText = constructorText,
                        FieldName = "_" + fieldName,
                        FieldType = fieldTypeString,
                        FieldTypeInfoComment = string.Format("// {0} {1};", TypeToString.GetTypeString(field.type), fieldName),
                        PropertyName = UserTypeField.GetPropertyName(fieldName, Symbol.name),
                        Static = isStatic,
                        UseUserMember = lazyCacheUserTypeFields,
                        CacheResult = cacheUserTypeFields || (isStatic && cacheStaticUserTypeFields),
                        SimpleFieldValue = simpleFieldValue,
                    };
            }

            return base.ExtractField(field, fieldType, factory, simpleFieldValue, gettingField, isStatic, options, extractingBaseClass);
        }
    }
}
