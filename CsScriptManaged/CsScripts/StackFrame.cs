using CsScriptManaged;
using DbgEngManaged;
using System;
using System.Text;

namespace CsScripts
{
    public class StackFrame
    {
        /// <summary>
        /// The frame
        /// </summary>
        private _DEBUG_STACK_FRAME frame;

        /// <summary>
        /// The source file name, line and displacement
        /// </summary>
        private SimpleCache<Tuple<string, uint, ulong>> sourceFileNameAndLine;

        /// <summary>
        /// The function name and displacement
        /// </summary>
        private SimpleCache<Tuple<string, ulong>> functionNameAndDisplacement;

        /// <summary>
        /// The local variables
        /// </summary>
        private SimpleCache<VariableCollection> locals;

        /// <summary>
        /// The arguments
        /// </summary>
        private SimpleCache<VariableCollection> arguments;

        /// <summary>
        /// Initializes a new instance of the <see cref="StackFrame"/> class.
        /// </summary>
        /// <param name="stackTrace">The stack trace.</param>
        /// <param name="frame">The frame.</param>
        internal StackFrame(StackTrace stackTrace, _DEBUG_STACK_FRAME frame)
        {
            StackTrace = stackTrace;
            this.frame = frame;
            sourceFileNameAndLine = SimpleCache.Create(ReadSourceFileNameAndLine);
            functionNameAndDisplacement = SimpleCache.Create(ReadFunctionNameAndDisplacement);
            locals = SimpleCache.Create(() => GetVariables(DebugScopeGroup.Locals));
            arguments = SimpleCache.Create(() => GetVariables(DebugScopeGroup.Arguments));
        }

        /// <summary>
        /// Gets the owning stack trace.
        /// </summary>
        public StackTrace StackTrace { get; internal set; }

        /// <summary>
        /// Gets the owning thread.
        /// </summary>
        public Thread Thread
        {
            get
            {
                return StackTrace.Thread;
            }
        }

        /// <summary>
        /// Gets a value indicating whether this <see cref="StackFrame"/> is virtual.
        /// </summary>
        /// <value>
        ///   <c>true</c> if this stack frame was generated by the debugger by unwinding; otherwise, <c>false</c> if it
        ///   was formed from a thread's current context. Typically, this is <c>true</c> for the frame at the top of the
        ///   stack, where InstructionOffset is the current instruction pointer.
        /// </value>
        public bool Virtual
        {
            get
            {
                return frame.Virtual != 0;
            }
        }

        /// <summary>
        /// Gets the index of the frame. This index counts the number of frames from the top of the call stack.
        /// The frame at the top of the stack, representing the current call, has index zero..
        /// </summary>
        public uint FrameNumber
        {
            get
            {
                return frame.FrameNumber;
            }
        }

        /// <summary>
        /// Gets the location in the process's virtual address space of the stack frame, if known.
        /// Some processor architectures do not have a frame or have more than one. In these cases,
        /// the engine chooses a value most representative for the given level of the stack.
        /// </summary>
        public ulong FrameOffset
        {
            get
            {
                return frame.FrameOffset;
            }
        }

        /// <summary>
        /// Gets the location in the process's virtual address space of the related instruction for the stack frame.
        /// This is typically the return address for the next stack frame, or the current instruction pointer if the
        /// frame is at the top of the stack. 
        /// </summary>
        public ulong InstructionOffset
        {
            get
            {
                return frame.InstructionOffset;
            }
        }

        /// <summary>
        /// Gets the location in the process's virtual address space of the return address for the stack frame.
        /// This is typically the related instruction for the previous stack frame.
        /// </summary>
        public ulong ReturnOffset
        {
            get
            {
                return frame.ReturnOffset;
            }
        }

        /// <summary>
        /// Gets the location in the process's virtual address space of the processor stack.
        /// </summary>
        public ulong StackOffset
        {
            get
            {
                return frame.StackOffset;
            }
        }

        /// <summary>
        /// Gets the name of the source file.
        /// </summary>
        public string SourceFileName
        {
            get
            {
                return sourceFileNameAndLine.Value.Item1;
            }
        }

        /// <summary>
        /// Gets the source file line.
        /// </summary>
        public uint SourceFileLine
        {
            get
            {
                return sourceFileNameAndLine.Value.Item2;
            }
        }

        /// <summary>
        /// Gets the source file displacement.
        /// </summary>
        public ulong SourceFileDisplacement
        {
            get
            {
                return sourceFileNameAndLine.Value.Item3;
            }
        }

        /// <summary>
        /// Gets the name of the function.
        /// </summary>
        public string FunctionName
        {
            get
            {
                return functionNameAndDisplacement.Value.Item1;
            }
        }

        /// <summary>
        /// Gets the function displacement.
        /// </summary>
        public ulong FunctionDisplacement
        {
            get
            {
                return functionNameAndDisplacement.Value.Item2;
            }
        }

        /// <summary>
        /// Gets the local variables.
        /// </summary>
        public VariableCollection Locals
        {
            get
            {
                return locals.Value;
            }
        }

        /// <summary>
        /// Gets the function arguments.
        /// </summary>
        public VariableCollection Arguments
        {
            get
            {
                return arguments.Value;
            }
        }

        /// <summary>
        /// Reads the name of the source file, line and displacement.
        /// </summary>
        /// <exception cref="System.AggregateException">Couldn't read source file name. Check if symbols are present.</exception>
        private Tuple<string, uint, ulong> ReadSourceFileNameAndLine()
        {
            try
            {
                uint fileNameLength, sourceFileLine;
                ulong displacement;
                StringBuilder sb = new StringBuilder(Constants.MaxFileName);

                Context.Symbols.GetLineByOffset(InstructionOffset, out sourceFileLine, sb, (uint)sb.Capacity, out fileNameLength, out displacement);
                return Tuple.Create(sb.ToString(), sourceFileLine, displacement);
            }
            catch (Exception ex)
            {
                throw new AggregateException("Couldn't read source file name. Check if symbols are present.", ex);
            }
        }

        /// <summary>
        /// Reads the function name and displacement.
        /// </summary>
        /// <returns></returns>
        /// <exception cref="System.AggregateException">Couldn't read source file name. Check if symbols are present.</exception>
        private Tuple<string, ulong> ReadFunctionNameAndDisplacement()
        {
            try
            {
                uint functionNameSize;
                ulong displacement;
                StringBuilder sb = new StringBuilder(Constants.MaxSymbolName);

                Context.Symbols.GetNameByOffset(InstructionOffset, sb, (uint)sb.Capacity, out functionNameSize, out displacement);
                return Tuple.Create(sb.ToString(), displacement);
            }
            catch (Exception ex)
            {
                throw new AggregateException("Couldn't read function name. Check if symbols are present.", ex);
            }
        }

        /// <summary>
        /// Gets the variables based on the scope group.
        /// </summary>
        /// <param name="scopeGroup">The scope group.</param>
        /// <returns>Array of variables</returns>
        private VariableCollection GetVariables(DebugScopeGroup scopeGroup)
        {
            using (StackFrameSwitcher switcher = new StackFrameSwitcher(this))
            {
                IDebugSymbolGroup2 symbolGroup;
                Context.Symbols.GetScopeSymbolGroup2((uint)scopeGroup, null, out symbolGroup);
                uint localsCount = symbolGroup.GetNumberSymbols();
                Variable[] variables = new Variable[localsCount];
                for (uint i = 0; i < localsCount; i++)
                {
                    StringBuilder name = new StringBuilder(Constants.MaxSymbolName);
                    uint nameSize;

                    symbolGroup.GetSymbolName(i, name, (uint)name.Capacity, out nameSize);
                    var entry = symbolGroup.GetSymbolEntryInformation(i);

                    variables[i] = new Variable(name.ToString(), entry);
                }

                return new VariableCollection(variables);
            }
        }
    }
}
